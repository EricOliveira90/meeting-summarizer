### 1. The "Heads-Up" Status Bar

Before the menu options appear, the user must see the **System State**. This anchors their expectations (e.g., "Don't expect a summary right now, the server is down"). Behind the scenes, the CLI runs a fast reconciliation (`cleanPhantomFiles`) to ensure these numbers perfectly match the files currently on your hard drive.

Plaintext


```

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SERVER: ðŸŸ¢ Online (12ms)   |   LOCAL QUEUE: 3 items        â”‚
â”‚  READY TO FETCH: 1          |   NEEDS ATTENTION: 0          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

```

- **Server Status:** Real-time "heartbeat" check upon app launch via `api.ts`.
    - *States:* ðŸŸ¢ Online, ðŸ”´ Offline, ðŸŸ¡ Reconnecting.
- **Local Queue:** Recordings finished but not yet acknowledged by the server (`WAITING_UPLOAD`).
- **Ready to Fetch:** Jobs that the server finished processing, ready to be saved to Obsidian (`READY`).
- **Needs Attention:** Jobs that hit their max retry limit or encountered a fatal error (`ABANDONED`).

---

### 2. The Dynamic Main Menu

The menu options should be action-oriented, with dynamic labels generated by querying `db.ts` that change based on the local state.

#### **A. [Record] Start New Session**
- *Always available, regardless of server status.*
- **UX Note:** When recording stops, if the server is offline, the system immediately notifies: *"Saved to Local Queue. Will sync when server is reachable."*

#### **B. [Sync] The Magic Batch Process**
- *The "Magic Button".* This is powered by `syncManager.ts` and processes the entire lifecycle in one click (Push Pending -> Update States -> Fetch Results).
- **Dynamic Labeling:**
    - If everything is up to date: `Sync (Up to date)`
    - If items are waiting: `Sync (2 Uploads | 1 Download)`
    - If server is offline but items are queued: `Sync (Server Offline - Cannot Sync)`
    - If jobs are in retry state: `Sync (1 Upload | 1 Retry)`

#### **C. [Jobs] View Processing Status**
- A list view of the local audit log (`client-db.json`). This satisfies the need to know "what's happening."
- **Columns:** `ID | Original Name | Status | Retries`
- **Status States & Colors (chalk):**
    - `WAITING_UPLOAD` (Cyan): Local only, ready to go.
    - `UPLOADING` (Blue): Currently sending.
    - `PROCESSING` (Purple): Server has it, transcribing/summarizing.
    - `READY` (Green): Finished, available for download.
    - `FAILED` (Yellow): Intermittent tunnel/network error. Will retry on next sync (e.g., Retry 1/3).
    - `ABANDONED` (Red): Fatal error (e.g., Bad API Key) or max retries hit. Allows manual override.
    - `DELETED` (Dark Gray/Strikethrough): User deleted the `.mkv` manually. Kept for audit history.

#### **D. [Library] Configs & Setup**
- View config information.
- Setup the configs (paths, API keys) and audio devices (Mic/Desktop).

---

### 3. User Flow Scenarios

#### **Scenario A: The "Offline" Recording**
1. **User:** Opens tool.
2. **Status Bar:** Shows `SERVER: ðŸ”´ Offline`.
3. **Action:** User selects `Start Recording`.
4. **End:** User stops recording.
5. **System:** "Recording saved locally. Added to Queue."
6. **Menu:** Updates to `Sync (1 Pending Upload)`.

#### **Scenario B: The "Magic Batch" Sync**
1. **User:** Opens tool later. Status Bar shows `SERVER: ðŸŸ¢ Online`.
2. **Menu:** Shows `Sync (3 Pending Uploads | 2 Ready to Fetch)`.
3. **Action:** User hits `Sync`.
4. **Feedback:** Progress bars appear. The system uploads the 3 new files, updates any active states, and downloads the 2 finished summaries automatically.
5. **Result:** All completed files are saved to Obsidian. Status returns to `Sync (Up to date)`.

#### **Scenario C: The "Ghost File" (Reconciliation)**
1. **User:** Records a meeting, but deletes the `.mkv` from Windows Explorer before syncing.
2. **Action:** User opens the CLI.
3. **System (Boot):** Runs `cleanPhantomFiles()`. Detects the missing file.
4. **Notification:** "ðŸ§¹ Cleaned up 1 ghost file that was missing from disk."
5. **Jobs View:** The record is now safely marked as `DELETED` instead of crashing the app on upload.

#### **Scenario D: The Flaky Tunnel (Retry Logic)**
1. **System:** Attempting to upload a large meeting.
2. **Event:** The SSH tunnel drops mid-upload.
3. **System:** Catches the network error. Marks job as `FAILED` (Retry 1/3).
4. **Action:** User hits `Sync` later when the connection is stable.
5. **System:** Successfully uploads the `FAILED` job and resets the retry counter.

---

### 4. Implementation Tip (Node.js/TypeScript)

To keep the codebase lean and maintainable for a single developer:
* Use **`inquirer`** for the menu, **`ora`** for batch-processing spinners, and **`chalk`** for color-coding states.
* Isolate all visual UI drawing into a dedicated `ui/cli-views.ts` file. 
* Clear the console (`console.clear()`) and reprint the Status Bar header on every menu loop refresh. This makes it feel like a persistent, reactive app UI rather than a scrolling terminal log.
